<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The only bubble speech meme generator you will need</title>
    <meta name="description" content="Generate memes with transparent speech bubbles instantly. Upload your image, carve in the bubble, and download with one click.">
    <meta name="keywords" content="meme generator, speech bubble meme, online meme maker, image editor">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:title" content="Bubble Speech Meme Generator">
    <meta property="og:description" content="The only bubble speech meme generator you will need.">
    <meta property="og:type" content="website">
    <style>
        :root { --accent: #3b82f6; }
        body { font-family: system-ui, sans-serif; text-align: center; margin: 2em; transition: background 0.3s, color 0.3s; }
        body.light { background: #f4f4f4; color: #000; }
        body.dark { background: #1e1e1e; color: #fff; }
        h1 { font-size: 1.8em; margin-bottom: 1em; }
        #dropzone { border: 2px dashed var(--accent); padding: 2em; border-radius: 12px; background: transparent; cursor: pointer; margin-bottom: 1em; transition: background 0.2s, box-shadow 0.2s; outline: none; }
        #dropzone:hover, #dropzone:focus { box-shadow: 0 2px 6px rgba(0,0,0,0.15); background: rgba(59,130,246,0.05); }
        .preview-wrap { max-width: 100%; margin: 1em 0; }
        canvas, img.preview-img { max-width: 100%; border: 1px solid currentColor; border-radius: 12px; background: #fff; display:block; margin: 0 auto; }
        body.dark canvas, body.dark img.preview-img { border: 1px solid #000; background: #1a1a1a; }
        button { margin: 0.5em; padding: 0.6em 1.2em; cursor: pointer; border: none; border-radius: 8px; background: var(--accent); color: #fff; font-weight: 500; transition: background 0.2s, transform 0.1s; }
        button:hover { background: #2563eb; transform: translateY(-1px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        #toggleMode { position: absolute; top: 1em; right: 1em; background: transparent; color: var(--accent); }
        .progress { border-radius:8px; padding:8px; }
        body.light .progress { background: #ececec; color: #000; }
        body.dark .progress { background: #2e2e2e; color: #fff; }
    </style>
</head>
<body class="dark">
<button id="toggleMode">Toggle Dark/Light</button>
<main>
    <h1>The only bubble speech meme generator you will need</h1>

    <section>
        <div id="dropzone" tabindex="0">Drop an image/GIF/video here, click to upload, or paste with Ctrl+V</div>
        <input type="file" id="fileInput" accept="image/*,video/*" hidden>
    </section>

    <section class="preview-wrap" id="previewWrap">
        <div id="progressContainer" style="width:100%;margin:1em auto;display:none;">
            <div class="progress">
                <div id="progressText" style="font-size:0.9rem;color:var(--accent);margin-bottom:6px;text-align:left;">&nbsp;</div>
                <div style="background:#e5e7eb;border-radius:6px;height:10px;overflow:hidden;">
                    <div id="progressBar" style="height:100%;width:0%;background:var(--accent);transition:width 160ms linear;"></div>
                </div>
            </div>
        </div>

        <canvas id="canvas" aria-label="Meme preview"></canvas>
    </section>

    <section>
        <button id="downloadBtn">Download</button>
    </section>
</main>

<footer>
    <p style="font-size:0.9em; opacity:0.7; margin-top:2em;">Made with ❤️ for meme creators</p>
</footer>

<script src="https://cdn.jsdelivr.net/gh/jnordberg/gif.js/dist/gif.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gif-frames@1.0.1/dist/gif-frames.min.js"></script>
<script>
    // --- DOM refs ---
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const previewWrap = document.getElementById('previewWrap');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const downloadBtn = document.getElementById('downloadBtn');
    const toggleModeBtn = document.getElementById('toggleMode');

    const progressText = document.getElementById('progressText');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');

    const MAX_FRAMES = 1000;

    let previewInterval = null;
    let currentGif = null;          // array of { canvas, delay }
    let isProcessing = false;

    // For background encoding & swapping preview
    let gifReadyBlob = null;
    let gifEncodingPromise = null;
    let previewImg = null;
    let previewImgUrl = null;

    downloadBtn.disabled = true;

    function setButtonsEnabled(enabled) {
        downloadBtn.disabled = !enabled;
    }

    function setProgress(percent, label = '') {
        if (!progressContainer) return;
        progressContainer.style.display = 'block';
        progressBar.style.width = Math.min(100, Math.max(0, percent)) + '%';
        progressText.textContent = label || '';
    }

    function resetProgress() {
        if (!progressContainer) return;
        progressContainer.style.display = 'none';
        progressBar.style.width = '0%';
        progressText.textContent = '';
    }

    // Bubble speech SVG path (as Path2D)
    const bubblePath = new Path2D("M -0.5,-0.5 C 532.833,-0.5 1066.17,-0.5 1599.5,-0.5C 1599.5,11.8333 1599.5,24.1667 1599.5,36.5C 1538.14,63.1198 1475.14,85.2865 1410.5,103C 1315.6,163.275 1220.93,223.775 1126.5,284.5C 1125.83,284.5 1125.17,284.5 1124.5,284.5C 1156.01,239.472 1188.01,194.806 1220.5,150.5C 1221.91,150.027 1222.57,149.027 1222.5,147.5C 1224.14,145.876 1223.8,144.876 1221.5,144.5C 944.641,189.472 667.975,188.306 391.5,141C 277.413,121.481 166.747,90.1473 59.5,47C 39.3589,38.0954 19.3589,28.9287 -0.5,19.5C -0.5,12.8333 -0.5,6.16667 -0.5,-0.5 Z");

    function applyBubbleMask(canvasEl, ctxEl) {
        const scale = canvasEl.width / 1600;
        ctxEl.save();
        ctxEl.scale(scale, scale);
        ctxEl.globalCompositeOperation = 'destination-out';
        ctxEl.fill(bubblePath);
        ctxEl.restore();
    }

    // We may swap canvas <-> img in DOM. Helpers:
    function showGifPreview(blob) {
        // Remove old previewImg if exists
        if (previewImgUrl) {
            URL.revokeObjectURL(previewImgUrl);
            previewImgUrl = null;
        }
        // Create image element
        const img = document.createElement('img');
        img.className = 'preview-img';
        img.alt = 'Preview GIF';
        img.style.maxWidth = '100%';
        img.style.display = 'block';

        previewImgUrl = URL.createObjectURL(blob);
        img.src = previewImgUrl;

        // Replace canvas with img in DOM
        if (canvas.parentNode) {
            canvas.parentNode.replaceChild(img, canvas);
        }
        previewImg = img;

        // Buttons remain enabled
        setButtonsEnabled(true);
        resetProgress();
    }

    function restoreCanvasIfNeeded() {
        if (!previewImg) return;
        // Put canvas back where image is
        if (previewImg.parentNode) {
            previewImg.parentNode.replaceChild(canvas, previewImg);
        }
        // clean up old img URL
        if (previewImgUrl) {
            URL.revokeObjectURL(previewImgUrl);
            previewImgUrl = null;
        }
        previewImg = null;
    }

    // Convert extracted frames into processed canvases (apply bubble mask)
    async function processFrames(frames, maxFrames = MAX_FRAMES) {
        const processedFrames = [];
        const framesToProcess = Math.min(frames.length, maxFrames);

        for (let i = 0; i < framesToProcess; i++) {
            const frame = frames[i];

            // create canvas for this frame
            const frameCanvas = document.createElement('canvas');
            const frameCtx = frameCanvas.getContext('2d', { willReadFrequently: true });
            frameCanvas.width = frame.width;
            frameCanvas.height = frame.height;

            frameCtx.putImageData(frame.imageData, 0, 0);
            applyBubbleMask(frameCanvas, frameCtx);

            processedFrames.push({ canvas: frameCanvas, delay: frame.delay });

            // map progress to 0..50%
            setProgress(((i + 1) / framesToProcess) * 50, 'Loading preview…');

            // yield occasionally so UI keeps responsive
            if (i % 20 === 0) await new Promise(r => setTimeout(r, 0));
        }

        return processedFrames;
    }

    // Play preview from processed frames (canvas-based)
    function updatePreview(processedFrames) {
        if (processedFrames.length === 0) {
            setButtonsEnabled(false);
            return;
        }

        // If we had swapped to <img> from a previous run, restore the canvas so preview uses canvas animation
        restoreCanvasIfNeeded();

        currentGif = processedFrames;
        setButtonsEnabled(true);

        canvas.width = processedFrames[0].canvas.width;
        canvas.height = processedFrames[0].canvas.height;

        if (previewInterval) {
            clearTimeout(previewInterval);
            previewInterval = null;
        }

        let frameIndex = 0;
        function drawFrame() {
            if (!currentGif || currentGif.length === 0) return;
            const frame = currentGif[frameIndex];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(frame.canvas, 0, 0);

            frameIndex = (frameIndex + 1) % currentGif.length;

            // use actual delay (ms)
            const delay = (frame.delay > 0) ? frame.delay : 100;
            previewInterval = setTimeout(drawFrame, delay);
        }

        drawFrame();

        // Start background GIF encoding (phase 2)
        gifEncodingPromise = createGif(currentGif)
            .then(blob => {
                gifReadyBlob = blob;
                // show real gif in DOM so native copy works
                try { showGifPreview(blob); } catch (e) { console.warn("Could not show gif preview:", e); }
                return blob;
            })
            .catch(err => {
                console.error("Background GIF encoding failed:", err);
                gifReadyBlob = null;
                gifEncodingPromise = null;
                resetProgress();
            });
    }

    function handleImage(img) {
        // When loading a new image, restore canvas if previously replaced by <img>
        restoreCanvasIfNeeded();

        canvas.width = img.width;
        canvas.height = img.height;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
        applyBubbleMask(canvas, ctx);
        currentGif = null;
        // There is a preview (static) so enable buttons
        setButtonsEnabled(true);
        // Cancel background gifPromise if any (we won't reuse it)
        gifReadyBlob = null;
        gifEncodingPromise = null;
        resetProgress();
    }

    // --- Video capture implementation (uses requestVideoFrameCallback if available) ---
    async function handleVideo(file) {
        if (isProcessing) return;
        isProcessing = true;
        dropzone.classList.add('processing');
        setButtonsEnabled(false);
        setProgress(0, 'Loading preview…');

        // If previous img was shown, restore canvas to animate onto
        restoreCanvasIfNeeded();

        try {
            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.muted = true;
            video.playsInline = true;
            video.crossOrigin = "anonymous";

            await new Promise((resolve, reject) => {
                const onMeta = () => { cleanup(); resolve(); };
                const onErr = (e) => { cleanup(); reject(e); };
                function cleanup() {
                    video.removeEventListener('loadedmetadata', onMeta);
                    video.removeEventListener('error', onErr);
                }
                video.addEventListener('loadedmetadata', onMeta, { once: true });
                video.addEventListener('error', onErr, { once: true });
            });

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            tempCanvas.width = video.videoWidth || 320;
            tempCanvas.height = video.videoHeight || 180;

            const frames = [];
            let lastVideoTime = -1;
            let stopped = false;

            function captureFrame(mediaTime) {
                if (lastVideoTime >= 0 && Math.abs(mediaTime - lastVideoTime) < 1e-3) return;

                let delay;
                if (lastVideoTime < 0) delay = 1000 / 30;
                else delay = Math.max(1, (mediaTime - lastVideoTime) * 1000);
                lastVideoTime = mediaTime;

                tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

                frames.push({ imageData, width: tempCanvas.width, height: tempCanvas.height, delay });
            }

            async function finishCapture(reason = "normal") {
                if (stopped) return;
                stopped = true;
                try {
                    // process frames
                    const processed = await processFrames(frames);
                    updatePreview(processed);
                } finally {
                    URL.revokeObjectURL(video.src);
                    isProcessing = false;
                    dropzone.classList.remove('processing');
                    setProgress(50, 'Preparing file for download…');
                }
            }

            if (typeof video.requestVideoFrameCallback === 'function') {
                try { await video.play(); } catch (e) { /* ignore autoplay block */ }

                const onFrame = (now, metadata) => {
                    const mediaTime = (metadata && metadata.mediaTime != null) ? metadata.mediaTime : video.currentTime;
                    captureFrame(mediaTime);

                    if (video.ended || frames.length >= MAX_FRAMES) {
                        finishCapture(video.ended ? "video ended" : "max frames");
                        return;
                    }

                    try { video.requestVideoFrameCallback(onFrame); }
                    catch (err) { console.error("rVFC failed:", err); startFallbackPoll(); }
                };

                video.requestVideoFrameCallback(onFrame);
                video.addEventListener('ended', () => finishCapture("ended event"), { once: true });

                setTimeout(() => {
                    if (!stopped) { console.warn("Safety timeout reached, finishing capture."); finishCapture("safety timeout"); }
                }, Math.max(20000, (video.duration || 10) * 1500));
            } else {
                // fallback polling
                try { await video.play(); } catch (e) { /* ignore autoplay block */ }

                let pollTimer = null;
                const POLL_MS = 1000 / 60;

                function startFallbackPoll() {
                    if (pollTimer) return;
                    pollTimer = setInterval(() => {
                        if (video.paused || video.ended || frames.length >= MAX_FRAMES) {
                            clearInterval(pollTimer);
                            finishCapture(video.ended ? "video ended" : "max frames");
                            return;
                        }
                        const mediaTime = video.currentTime;
                        if (lastVideoTime < 0 || (mediaTime - lastVideoTime) >= 0.008) {
                            captureFrame(mediaTime);
                        }
                    }, POLL_MS);
                }

                startFallbackPoll();
                video.addEventListener('ended', () => {
                    if (pollTimer) clearInterval(pollTimer);
                    finishCapture("ended event");
                }, { once: true });

                setTimeout(() => {
                    if (!stopped) {
                        if (pollTimer) clearInterval(pollTimer);
                        finishCapture("safety timeout");
                    }
                }, Math.max(20000, (video.duration || 10) * 1500));
            }

        } catch (err) {
            console.error('Error processing video:', err);
            alert('Error processing file. Please try a different format.');
            isProcessing = false;
            dropzone.classList.remove('processing');
            resetProgress();
        }
    }

    // --- GIF handling ---
    async function handleGif(file) {
        if (isProcessing) return;
        isProcessing = true;
        dropzone.classList.add('processing');
        setButtonsEnabled(false);
        setProgress(0, 'Loading preview…');

        // restore canvas if we swapped previously
        restoreCanvasIfNeeded();

        try {
            const fileUrl = URL.createObjectURL(file);

            const frameData = await gifFrames({
                url: fileUrl,
                frames: 'all',
                outputType: 'canvas',
                cumulative: true
            });

            const frames = [];
            for (const frame of frameData) {
                const c = frame.getImage();
                const cctx = c.getContext('2d');
                const imageData = cctx.getImageData(0, 0, c.width, c.height);
                frames.push({ imageData, width: c.width, height: c.height, delay: (frame.frameInfo.delay || 10) * 10 });
            }

            const processedFrames = await processFrames(frames);
            updatePreview(processedFrames);

            URL.revokeObjectURL(fileUrl);
        } catch (err) {
            console.error('Error processing GIF:', err);
            alert('Error processing GIF file. Please try a different format.');
        } finally {
            isProcessing = false;
            dropzone.classList.remove('processing');
        }
    }

    function handleFile(file) {
        // reset any prior blob state when new file arrives
        gifReadyBlob = null;
        gifEncodingPromise = null;
        resetProgress();
        setButtonsEnabled(false);

        if (file.type.startsWith('image/gif') || file.name.toLowerCase().endsWith('.gif')) {
            handleGif(file);
        } else if (file.type.startsWith('video/')) {
            handleVideo(file);
        } else if (file.type.startsWith('image/')) {
            const img = new Image();
            img.onload = () => handleImage(img);
            img.src = URL.createObjectURL(file);
        }
    }

    // --- GIF encoding (background) ---
    function createGif(frames) {
        // returns a Promise<Blob>
        setProgress(50, 'Preparing file for download…');

        return fetch('https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js')
            .then(response => {
                if (!response.ok) throw new Error("Failed to fetch worker script");
                return response.blob();
            })
            .then(workerBlob => {
                return new Promise((resolve, reject) => {
                    const gif = new GIF({
                        workerScript: URL.createObjectURL(workerBlob),
                        workers: 2,
                        quality: 10,
                        width: frames[0].canvas.width,
                        height: frames[0].canvas.height,
                        transparent: 0x00000000
                    });

                    frames.forEach((frame, index) => {
                        gif.addFrame(frame.canvas, { delay: frame.delay });
                    });

                    gif.on('progress', p => {
                        setProgress(50 + p * 50, 'Preparing file for download…');
                    });

                    gif.on('finished', blob => {
                        resetProgress();
                        resolve(blob);
                    });

                    gif.on('abort', () => reject(new Error('GIF generation aborted')));
                    gif.on('error', reject);

                    gif.render();
                });
            });
    }


    // --- Events / UI wiring ---
    dropzone.onclick = () => fileInput.click();
    dropzone.ondragover = (e) => { e.preventDefault(); dropzone.style.background = 'rgba(59,130,246,0.1)'; };
    dropzone.ondragleave = () => { dropzone.style.background = 'transparent'; };
    dropzone.ondrop = (e) => { e.preventDefault(); dropzone.style.background = 'transparent'; if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]); };

    dropzone.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); fileInput.click(); } });

    document.addEventListener('paste', (e) => {
        const items = e.clipboardData?.items;
        if (!items) return;
        for (const item of items) {
            if (item.type.startsWith('image/')) {
                const f = item.getAsFile();
                if (f) { handleFile(f); break; }
            }
        }
    });
    dropzone.addEventListener('paste', (e) => { /* same as above—global catches it already */ });

    fileInput.onchange = (e) => { if (e.target.files.length) handleFile(e.target.files[0]); };

    downloadBtn.onclick = async () => {
        // Animated (multi-frame)
        if (currentGif && currentGif.length > 1) {
            if (!gifEncodingPromise) return;
            setButtonsEnabled(false);
            try {
                const blob = gifReadyBlob || await gifEncodingPromise;
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = 'bubble-meme.gif';
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            } finally {
                setButtonsEnabled(true);
            }
        } else {
            // Static PNG
            canvas.toBlob(blob => {
                if (!blob) return;
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = 'bubble-meme.png';
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            });
        }
    };

    toggleModeBtn.onclick = () => {
        document.body.classList.toggle('dark');
        document.body.classList.toggle('light');
    };

    // Expose a small helper to restore canvas (for dev)
    window.__restoreCanvas = restoreCanvasIfNeeded;
</script>
</body>
</html>
