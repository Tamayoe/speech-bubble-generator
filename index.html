<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The only bubble speech meme generator you will need</title>
  <meta name="description" content="Generate memes with transparent speech bubbles instantly. Upload your image, carve in the bubble, and copy or download with one click.">
  <meta name="keywords" content="meme generator, speech bubble meme, online meme maker, image editor">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:title" content="Bubble Speech Meme Generator">
  <meta property="og:description" content="The only bubble speech meme generator you will need.">
  <meta property="og:type" content="website">
  <style>
    :root {
      --accent: #3b82f6; /* soft blue */
    }
    body { font-family: system-ui, sans-serif; text-align: center; margin: 2em; transition: background 0.3s, color 0.3s; }
    body.light { background: #f4f4f4; color: #000; }
    body.dark { background: #1e1e1e; color: #fff; }
    h1 { font-size: 1.8em; margin-bottom: 1em; }
    #dropzone {
      border: 2px dashed var(--accent);
      padding: 2em;
      border-radius: 12px;
      background: transparent;
      cursor: pointer;
      margin-bottom: 1em;
      transition: background 0.2s, box-shadow 0.2s;
      outline: none;
    }
    #dropzone:hover, #dropzone:focus {
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      background: rgba(59,130,246,0.05);
    }
    canvas {
      max-width: 100%;
      margin: 1em 0;
      border: 1px solid currentColor;
      border-radius: 12px;
      background: #fff;
    }
    body.dark canvas {
      border: 1px solid #000;
      background: #1a1a1a;
    }
    button {
      margin: 0.5em;
      padding: 0.6em 1.2em;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      background: var(--accent);
      color: #fff;
      font-weight: 500;
      transition: background 0.2s, transform 0.1s;
    }
    button:hover { background: #2563eb; transform: translateY(-1px); }
    #toggleMode {
      position: absolute;
      top: 1em;
      right: 1em;
      background: transparent;
      color: var(--accent);
    }
    .processing {
      opacity: 0.7;
      pointer-events: none;
    }
    .processing::after {
      content: " (Processing...)";
      font-size: 0.9em;
      opacity: 0.8;
    }
  </style>
</head>
<body class="dark">
  <button id="toggleMode">Toggle Dark/Light</button>
  <main>
    <h1>The only bubble speech meme generator you will need</h1>

    <section>
      <div id="dropzone" tabindex="0">Drop an image/GIF/video here, click to upload, or paste with Ctrl+V</div>
      <input type="file" id="fileInput" accept="image/*,video/*" hidden>
    </section>

    <section>
      <canvas id="canvas" aria-label="Meme preview"></canvas>
    </section>

    <section>
      <button id="copyBtn">Copy</button>
      <button id="downloadBtn">Download</button>
    </section>
  </main>

  <footer>
    <p style="font-size:0.9em; opacity:0.7; margin-top:2em;">Made with ❤️ for meme creators</p>
  </footer>

  <script src="https://cdn.jsdelivr.net/gh/jnordberg/gif.js/dist/gif.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gif-frames@1.0.1/dist/gif-frames.min.js"></script>
  <script>
    let gif = null
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const copyBtn = document.getElementById('copyBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const toggleModeBtn = document.getElementById('toggleMode');

    const MAX_FRAMES = 1000

    let previewInterval = null;
    let currentGif = null;
    let isProcessing = false;

    

    // Bubble speech SVG path (as Path2D)
    const bubblePath = new Path2D("M -0.5,-0.5 C 532.833,-0.5 1066.17,-0.5 1599.5,-0.5C 1599.5,11.8333 1599.5,24.1667 1599.5,36.5C 1538.14,63.1198 1475.14,85.2865 1410.5,103C 1315.6,163.275 1220.93,223.775 1126.5,284.5C 1125.83,284.5 1125.17,284.5 1124.5,284.5C 1156.01,239.472 1188.01,194.806 1220.5,150.5C 1221.91,150.027 1222.57,149.027 1222.5,147.5C 1224.14,145.876 1223.8,144.876 1221.5,144.5C 944.641,189.472 667.975,188.306 391.5,141C 277.413,121.481 166.747,90.1473 59.5,47C 39.3589,38.0954 19.3589,28.9287 -0.5,19.5C -0.5,12.8333 -0.5,6.16667 -0.5,-0.5 Z");

    function applyBubbleMask(canvas, ctx) {
      const scale = canvas.width / 1600;
      ctx.save();
      ctx.scale(scale, scale);
      ctx.globalCompositeOperation = 'destination-out';
      ctx.fill(bubblePath);
      ctx.restore();
    }

    async function processFrames(frames, maxFrames = MAX_FRAMES) {
      console.log('[processFrames] Input frames:', frames.length);
      const processedFrames = [];
      const framesToProcess = Math.min(frames.length, maxFrames);

      for (let i = 0; i < framesToProcess; i++) {
        const frame = frames[i];

        // Create canvas for this frame
        const frameCanvas = document.createElement('canvas');
        const frameCtx = frameCanvas.getContext('2d');
        frameCanvas.width = frame.width;
        frameCanvas.height = frame.height;

        // Draw the frame image data
        frameCtx.putImageData(frame.imageData, 0, 0);

        // Apply the bubble mask
        applyBubbleMask(frameCanvas, frameCtx);

        // ⚠️ IMPORTANT: keep the original delay
        processedFrames.push({
          canvas: frameCanvas,
          delay: frame.delay
        });
      }

      return processedFrames;
    }

    function updatePreview(processedFrames) {
      if (processedFrames.length === 0) return;

      currentGif = processedFrames;
      canvas.width = processedFrames[0].canvas.width;
      canvas.height = processedFrames[0].canvas.height;

      if (previewInterval) {
        clearTimeout(previewInterval);
        previewInterval = null;
      }

      let frameIndex = 0;

      function drawFrame() {
        const frame = currentGif[frameIndex];
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(frame.canvas, 0, 0);

        frameIndex = (frameIndex + 1) % currentGif.length;

        // ✅ use actual delay, fallback to ~100ms if missing
        const delay = frame.delay > 0 ? frame.delay : 100;

        previewInterval = setTimeout(drawFrame, delay);
      }

      drawFrame();
    }

    async function handleVideo(file) {
      if (isProcessing) return;
      isProcessing = true;
      dropzone.classList.add('processing');

      try {
        const video = document.createElement('video');
        video.src = URL.createObjectURL(file);
        video.muted = true;
        video.playsInline = true;
        video.crossOrigin = "anonymous";

        await new Promise((resolve, reject) => {
          const onMeta = () => { cleanup(); resolve(); };
          const onErr = (e) => { cleanup(); reject(e); };
          function cleanup() {
            video.removeEventListener('loadedmetadata', onMeta);
            video.removeEventListener('error', onErr);
          }
          video.addEventListener('loadedmetadata', onMeta, { once: true });
          video.addEventListener('error', onErr, { once: true });
        });

        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = video.videoWidth || 320;
        tempCanvas.height = video.videoHeight || 180;

        const frames = [];
        let lastVideoTime = -1;
        let stopped = false;

        function captureFrame(mediaTime) {
          if (lastVideoTime >= 0 && Math.abs(mediaTime - lastVideoTime) < 1e-3) return;

          let delay;
          if (lastVideoTime < 0) {
            delay = 1000 / 30;
          } else {
            delay = Math.max(1, (mediaTime - lastVideoTime) * 1000);
          }
          lastVideoTime = mediaTime;

          tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
          const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

          frames.push({
            imageData,
            width: tempCanvas.width,
            height: tempCanvas.height,
            delay
          });
        }

        async function finishCapture(reason = "normal") {
          if (stopped) return;
          stopped = true;
          try {
            const processed = await processFrames(frames);
            updatePreview(processed);
          } finally {
            URL.revokeObjectURL(video.src);
            isProcessing = false;
            dropzone.classList.remove('processing');
          }
        }

        if (typeof video.requestVideoFrameCallback === 'function') {
          console.log("[handleVideo] Using requestVideoFrameCallback API");

          try { await video.play(); console.log("[handleVideo] Video playback started."); } catch (e) {
            console.warn("[handleVideo] video.play() failed:", e);
          }

          const onFrame = (now, metadata) => {
            const mediaTime = (metadata && metadata.mediaTime != null)
              ? metadata.mediaTime
              : video.currentTime;

            captureFrame(mediaTime);

            if (video.ended || frames.length >= MAX_FRAMES) {
              finishCapture(video.ended ? "video ended" : "max frames");
              return;
            }

            try {
              video.requestVideoFrameCallback(onFrame);
            } catch (err) {
              console.error("[handleVideo] rVFC failed, falling back:", err);
              startFallbackPoll();
            }
          };

          video.requestVideoFrameCallback(onFrame);
          video.addEventListener('ended', () => finishCapture("ended event"), { once: true });

          setTimeout(() => {
            if (!stopped) {
              console.warn("[handleVideo] Safety timeout reached, finishing capture.");
              finishCapture("safety timeout");
            }
          }, Math.max(20000, (video.duration || 10) * 1500));

        } else {
          console.log("[handleVideo] Using fallback polling capture");

          try { await video.play(); console.log("[handleVideo] Video playback started (fallback)."); } catch (e) {
            console.warn("[handleVideo] video.play() failed (fallback):", e);
          }

          let pollTimer = null;
          const POLL_MS = 1000 / 60;

          function startFallbackPoll() {
            if (pollTimer) return;
            pollTimer = setInterval(() => {
              if (video.paused || video.ended || frames.length >= MAX_FRAMES) {
                clearInterval(pollTimer);
                finishCapture(video.ended ? "video ended" : "max frames");
                return;
              }
              const mediaTime = video.currentTime;
              if (lastVideoTime < 0 || (mediaTime - lastVideoTime) >= 0.008) {
                captureFrame(mediaTime);
              }
            }, POLL_MS);
          }

          startFallbackPoll();
          video.addEventListener('ended', () => {
            if (pollTimer) clearInterval(pollTimer);
            finishCapture("ended event");
          }, { once: true });

          setTimeout(() => {
            if (!stopped) {
              console.warn("[handleVideo] Safety timeout reached (fallback).");
              if (pollTimer) clearInterval(pollTimer);
              finishCapture("safety timeout");
            }
          }, Math.max(20000, (video.duration || 10) * 1500));
        }

      } catch (err) {
        console.error('Error processing video:', err);
        alert('Error processing file. Please try a different format.');
        isProcessing = false;
        dropzone.classList.remove('processing');
      }
    }



    // Enhanced GIF handling with proper frame extraction
    async function handleGif(file) {
      if (isProcessing) return;
      isProcessing = true;
      dropzone.classList.add('processing');
      
      try {
        // Create URL for the file
        const fileUrl = URL.createObjectURL(file);
        
        // Use gif-frames library to extract frames with cumulative option
        const frameData = await gifFrames({ 
          url: fileUrl, 
          frames: 'all', 
          outputType: 'canvas',
          cumulative: true  // This composites frames properly
        });
        
        const frames = [];
        
        // Process each frame from the GIF
        for (let i = 0; i < frameData.length; i++) {
          const frame = frameData[i];
          const canvas = frame.getImage();
          const ctx = canvas.getContext('2d');
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          
          frames.push({
            imageData: imageData,
            width: canvas.width,
            height: canvas.height,
            delay: frame.frameInfo.delay * 10, // Convert centiseconds to milliseconds
            isGifFrame: true // Flag to identify GIF frames
          });
        }
        
        // Process all frames with bubble mask
        const processedFrames = await processFrames(frames);
        
        // Update preview
        updatePreview(processedFrames);
        
        // Clean up
        URL.revokeObjectURL(fileUrl);
        
      } catch (error) {
        console.error('Error processing GIF:', error);
        alert('Error processing GIF file. Please try a different format.');
      } finally {
        isProcessing = false;
        dropzone.classList.remove('processing');
      }
    }


    function handleFile(file) {
      if (file.type.startsWith('image/gif') || file.name.toLowerCase().endsWith('.gif')) {
        handleGif(file);
      } else if (file.type.startsWith('video/')) {
        handleVideo(file);
      } else if (file.type.startsWith('image/')) {
        const img = new Image();
        img.onload = () => handleImage(img);
        img.src = URL.createObjectURL(file);
      }
    }

    // Clipboard paste support
    async function handlePaste(e) {
      const items = e.clipboardData?.items;
      if (!items) return;

      for (const item of items) {
        if (item.type.startsWith('image/')) {
          const file = item.getAsFile();
          if (file) {
            handleFile(file);
            break;
          }
        }
      }
    }

    // Event listeners
    dropzone.onclick = () => fileInput.click();

    dropzone.ondragover = (e) => { 
      e.preventDefault(); 
      dropzone.style.background = 'rgba(59,130,246,0.1)'; 
    };
    
    dropzone.ondragleave = () => { 
      dropzone.style.background = 'transparent'; 
    };
    
    dropzone.ondrop = (e) => {
      e.preventDefault();
      dropzone.style.background = 'transparent';
      if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
    };

    // Keyboard support for dropzone
    dropzone.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        fileInput.click();
      }
    });

    // Global paste support
    document.addEventListener('paste', handlePaste);
    dropzone.addEventListener('paste', handlePaste);

    fileInput.onchange = (e) => {
      if (e.target.files.length) handleFile(e.target.files[0]);
    };

    copyBtn.onclick = async () => {
      if (currentGif) {
        // For GIFs, copy first frame as static image
        canvas.toBlob(blob => {
          const item = new ClipboardItem({ 'image/png': blob });
          navigator.clipboard.write([item]);
        });
      } else {
        canvas.toBlob(blob => {
          const item = new ClipboardItem({ 'image/png': blob });
          navigator.clipboard.write([item]);
        });
      }
    };

    downloadBtn.onclick = () => {
      if (currentGif && currentGif.length > 1) {
        // Use the same processed frames from preview
        fetch('https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js')
          .then(response => {
            if (!response.ok) throw new Error("Failed to fetch worker script");
            return response.blob();
          })
          .then(workerBlob => {
            const gif = new GIF({
              workerScript: URL.createObjectURL(workerBlob),
              workers: 2,
              quality: 10,
              width: currentGif[0].canvas.width,
              height: currentGif[0].canvas.height,
              transparent: 0x00000000
            });

            currentGif.forEach(frame => {
              gif.addFrame(frame.canvas, { delay: frame.delay });
            });

            gif.on('finished', function(blob) {
              const link = document.createElement('a');
              link.download = 'bubble-meme.gif';
              link.href = URL.createObjectURL(blob);
              link.click();
            });

            gif.render();
          })
          .catch(err => {
            console.error("GIF generation failed:", err);
            alert("Could not generate GIF.");
          });

      } else {
        // Just save PNG if static
        const link = document.createElement('a');
        link.download = 'bubble-meme.png';
        link.href = canvas.toDataURL();
        link.click();
      }
    };

    toggleModeBtn.onclick = () => {
      document.body.classList.toggle('dark');
      document.body.classList.toggle('light');
    };
  </script>
</body>
</html>